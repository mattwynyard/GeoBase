[
 {
  "file": "/Users/Matt/XCode/GeoBase/GeoBase/CompassController.swift",
  "offset": 2637,
  "remove": 9708,
  "text": "let newRecord = DataModel(entity: entity!, insertIntoManagedObjectContext: context)\n        let message: String = \"\\(structLabel.text!): \\(strikeLabel.text!)/\\(dipLabel.text!)\"\n        \n        newRecord.date = printTimestamp()\n        newRecord.dip = dipInt32\n        newRecord.direction = direction\n        newRecord.elevation = currentLocation.altitude\n        \n        newRecord.latitude = currentLocation.coordinate.latitude\n        newRecord.longitude = currentLocation.coordinate.longitude\n        newRecord.strike = strikeInt32\n        \n        if useTrueNorth == true {\n            newRecord.north = \"true\"\n        } else {\n            newRecord.north = \"magnetic\"\n        }\n        \n        print(newRecord)\n        //newRecord.structure\n        \n        \n        let alertController = UIAlertController(title: \"Save to Database\", message: message , preferredStyle: .Alert)\n        let cancelAction = UIAlertAction(title: \"Cancel\", style: .Cancel) { (action) in\n            // ...\n        }\n        alertController.addAction(cancelAction)\n        \n        let OKAction = UIAlertAction(title: \"OK\", style: .Default) { (action) in\n            // ...\n        }\n        alertController.addAction(OKAction)\n        \n        self.presentViewController(alertController, animated: true) {\n            // ...\n        }\n        \n        \n    }\n    \n    override func viewDidLoad() {\n        \n        super.viewDidLoad()\n        \n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.delegate = self\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingLocation()\n        startLocation = nil\n        structLabel.text = \"Strike\"\n        struct2Label.text = \"Dip\"\n        \n        structSelector.selectedSegmentIndex = 1 // strike/dip\n        useTrueNorth = NSUserDefaults.standardUserDefaults().boolForKey(\"northSwitch\");\n        \n        if useTrueNorth == true {\n            print(\"on\")\n            headingLabel.text = \"True North\"\n        } else {\n            print(\"off\")\n            headingLabel.text = \"Magnetic North\"\n        }\n        \n        if CLLocationManager.headingAvailable() {\n            \n            locationManager.headingFilter = 0.5 //take new reading tolerance +/- degree change\n            locationManager.headingOrientation = .Portrait\n            locationManager.startUpdatingHeading()\n            startMotion()\n        }\n       \n         print(currentProject)\n    }\n    \n    /** LOCATION MANAGER FUNCTIONS */\n    //*****************************************************\n    \n    func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        \n        self.locationArray = locations as NSArray //array to hold GPS readings\n        self.currentLocation = locationArray.lastObject as! CLLocation\n        \n        latitudeLabel.text = String(format: \"%+.4f\", currentLocation.coordinate.latitude) + \"\\u{00B0}\" //degrees\n        //longitudeLabel.text = String(format: \"%+.4f\", currentLocation.coordinate.longitude) + \"\\u{00B0}\"\n        horizontalAccuracy.text = \"\\u{00B1}\" + String(format: \"%.1f\", currentLocation.horizontalAccuracy) + \" m\"\n        //elevationLabel.text = String(format: \"%+.2f\", currentLocation.altitude) + \" m\"\n        //accuracyVerticalLabel.text = \"\\u{00B1}\" + String(format: \"%.1f\", currentLocation.verticalAccuracy) + \" m\"\n        \n        if startLocation == nil {\n            startLocation = currentLocation as CLLocation\n        }\n        \n        var distanceBetween: CLLocationDistance = currentLocation.distanceFromLocation(startLocation)\n        \n        //distanceLabel.text = String(format: \"%.2f\", distanceBetween)\n        \n    }\n    \n    func locationManager(manager: CLLocationManager, didUpdateHeading currentHeading: CLHeading) {\n        \n        var magHeading = currentHeading.magneticHeading\n        var trueHeading = currentHeading.trueHeading // will be -1 if we have no location info\n        var headingAccuracy = currentHeading.headingAccuracy\n        \n        if useTrueNorth {\n            heading = currentHeading.trueHeading\n        } else {\n            heading = currentHeading.magneticHeading\n        }\n        strikeInt32 = Int32(round(heading))\n        dipInt32 = Int32(round(dipDouble))\n        \n        if (structSelector.selectedSegmentIndex == 1) {\n            strikeLabel.text = String(format: \"%03.f\", heading) + \"\\u{00B0}\"\n            direction = setDirection(heading, roll: dipDouble)\n            \n        } else if (pitch < 0){\n           strikeLabel.text = String(format: \"%03.f\", (heading) % 360) + \"\\u{00B0}\"\n        } else {\n            strikeLabel.text = String(format: \"%03.f\", (heading + 180) % 360) + \"\\u{00B0}\"\n        }\n        \n    }\n    \n    /* Gets the dip direction of the reading\n    *\n    * @param heading - equivalent to strike\n    * @param roll - equivalent to dip\n    * @return String with dip direction\n    */\n    func setDirection(heading: Double, roll: Double) -> String {\n        \n        if (heading >= 347.5 && heading <= 360) || (heading >= 0 && heading < 22.5){\n            if roll < 0 {\n                return \"W\"\n            } else {\n                return \"E\"\n            }\n        } else if heading >= 22.5 && heading < 67.5 {\n            if roll < 0 {\n                return \"NW\"\n            } else {\n                return \"SE\"\n            }\n        } else if heading >= 67.5 && heading < 112.5 {\n            if roll < 0 {\n                return \"N\"\n            } else {\n                return \"S\"\n            }\n        } else if heading >= 112.5 && heading < 157.5 {\n            if roll < 0 {\n                return \"NE\"\n            } else {\n                return \"SW\"\n            }\n        } else if heading >= 157.5 && heading < 202.5 {\n            if roll < 0 {\n                return \"E\"\n            } else {\n                return \"W\"\n            }\n        } else if heading >= 202.5 && heading < 247.5 {\n            if roll < 0 {\n                return \"SE\"\n            } else {\n                return \"NW\"\n            }\n        } else if heading >= 247.5 && heading < 292.5 {\n            if roll < 0 {\n                return \"S\"\n            } else {\n                return \"N\"\n            }\n        } else if heading >= 292.5 && heading < 347.5 {\n            if roll < 0 {\n                return \"SW\"\n            } else {\n                return \"NE\"\n            }\n        } else {\n            return \"error\"\n        }\n    }\n    \n    /* \n    * Function to get current date and time\n    * @return String: the current date and time\n    */\n    func printTimestamp() -> String {\n        \n        let date = NSDate()\n        let formatter = NSDateFormatter()\n        formatter.dateFormat = \"dd-MM-yyyy HH:mm:ss\"\n        let timestamp = formatter.stringFromDate(date)\n        \n        return timestamp\n    }\n    \n    func getLatitude() -> CLLocationDegrees {\n        \n        let location = locationArray.lastObject as! CLLocation\n        return location.coordinate.latitude\n    }\n    \n    func getLongitude() -> CLLocationDegrees {\n        \n        let location = locationArray.lastObject as! CLLocation\n        return location.coordinate.longitude\n    }\n    \n    // *************************************\n    // start device motion capture\n    // *************************************\n    func startMotion() {\n        \n        let queue = NSOperationQueue.currentQueue()\n        \n        if motionManager.deviceMotionAvailable {\n            \n            motionManager.deviceMotionUpdateInterval = 0.1 //update every 0.1 second\n    \n           motionManager.startDeviceMotionUpdatesUsingReferenceFrame(CMAttitudeReferenceFrame.XArbitraryZVertical, toQueue: queue) {\n                [weak self] (data: CMDeviceMotion!, error: NSError!) in\n            \n                self?.pitch = (data.attitude.pitch * 180) / M_PI\n                let yaw = (data.attitude.yaw * 180) / M_PI\n                let roll = (data.attitude.roll * 180) / M_PI \n                //self?.yawLabel.text = String(format: \"%.1f\", yaw)\n            \n                if (self?.structSelector.selectedSegmentIndex == 1) { //strike/dip segmented control selected\n                    \n                    //println(data.attitude.roll) //need to fix dip going over 90deg\n                    \n                    self?.dipDouble = (data.attitude.roll * 180) / M_PI\n                    self?.dip = String(format: \"%.1f\", data.attitude.roll)\n                    self?.dipLabel.text = String(format: \"%.f\", abs(self!.dipDouble))\n                        + \" \" + self!.direction\n                    self?.pitchLabel.text = String(format: \"%.1f\", self!.pitch)\n                    \n                } else { //trend/plunge\n                    \n                    self?.dipDouble = (data.attitude.pitch * 180) / M_PI\n                    self?.dip = String(format: \"%.1f\", data.attitude.pitch)\n                    self?.dipLabel.text = String(format: \"%.f\", abs(self!.dipDouble))\n                    self?.pitchLabel.text = String(format: \"%.1f\", roll)\n            }\n            \n            }\n        }\n        NSOperationQueue.mainQueue().addOperationWithBlock {\n                \n        }\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n    \n    func locationManagerShouldDisplayHeadingCalibration(manager: CLLocationManager) -> Bool {\n        \n        return true // if you want the calibration dialog to be able to appear\n    }\n    \n    /* ERRORS */\n    //********************************************************\n    func locationManager(manager: CLLocationManager, didFailWithError error: NSError",
 }
]
